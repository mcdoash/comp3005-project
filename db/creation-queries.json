{
    "query": "CREATE TABLE Publisher ( Name VARCHAR(30) PRIMARY KEY, Email VARCHAR(30) NOT NULL UNIQUE, Address_name VARCHAR(30) NOT NULL, Address_street VARCHAR(30) NOT NULL, Address_city VARCHAR(25) NOT NULL, Address_prov CHAR(2) NOT NULL, Address_postal VARCHAR(10) NOT NULL, Address_country VARCHAR(20) NOT NULL, Address_phone VARCHAR(12) NOT NULL, Account_name VARCHAR(30) NOT NULL, Account_num VARCHAR(25) NOT NULL, CONSTRAINT valid_email CHECK (Email ~ '(?!.*[.]{2}|[.])[a-zA-Z0-9!#$%&''*+\\-\\/=?^_`{|}~.]+@[a-zA-Z0-9\\-]+.[a-zA-Z]+'), CONSTRAINT provience_length CHECK (LENGTH(Address_prov) = 2), CONSTRAINT phone_format CHECK (Address_phone ~ '[0-9]{3}-[0-9]{3}-[0-9]{4}') ); CREATE TABLE Contact ( Number VARCHAR(12) PRIMARY KEY, Name VARCHAR(30) NOT NULL, CONSTRAINT number_format CHECK (Number ~ '[0-9]{3}-[0-9]{3}-[0-9]{4}') ); CREATE TABLE Phone_num ( Number VARCHAR(12), Publisher VARCHAR(30), Contact_role VARCHAR(20) NOT NULL, PRIMARY KEY (Number, Publisher), FOREIGN KEY (Number) REFERENCES Contact (Number), FOREIGN KEY (Publisher) REFERENCES Publisher (Name) ON DELETE CASCADE ); CREATE TABLE Book ( ISBN CHAR(10) PRIMARY KEY, Title VARCHAR(50) NOT NULL, Cover VARCHAR(50), Publisher VARCHAR(30) NOT NULL, Blurb VARCHAR(2500), Price numeric(5, 2) NOT NULL, Page_num SMALLINT NOT NULL, Book_format VARCHAR(20) NOT NULL, Release_date DATE NOT NULL, Copies_sold SMALLINT NOT NULL DEFAULT 0, Stock SMALLINT NOT NULL, Sale_percent numeric(3, 2) NOT NULL, Selling BOOLEAN NOT NULL DEFAULT TRUE, FOREIGN KEY (Publisher) REFERENCES Publisher (Name), CONSTRAINT valid_isbn CHECK (ISBN ~ '[0-9]{9}[0-9x]'), CONSTRAINT positive_price CHECK (Price >= 0), CONSTRAINT positive_sold CHECK (Copies_sold >= 0), CONSTRAINT positive_stock CHECK (Stock >= 0), CONSTRAINT valid_percentage CHECK (Sale_percent <= 1 AND Sale_percent >= 0) ); CREATE TABLE Genre ( Name VARCHAR(25), Book CHAR(10), PRIMARY KEY (Name, Book), FOREIGN KEY (Book) REFERENCES Book (ISBN) ON DELETE CASCADE ); CREATE TABLE Authored ( Author VARCHAR(30), Book CHAR(10), PRIMARY KEY (Author, Book), FOREIGN KEY (Book) REFERENCES Book (ISBN) ON DELETE CASCADE ); CREATE TABLE Account ( Email VARCHAR(30) PRIMARY KEY, Fname VARCHAR(15) NOT NULL, Lname VARCHAR(20) NOT NULL, Password VARCHAR(30) NOT NULL, CONSTRAINT valid_email CHECK (Email ~ '(?!.*[.]{2}|[.])[a-zA-Z0-9!#$%&''*+\\-\\/=?^_`{|}~.]+@[a-zA-Z0-9\\-]+.[a-zA-Z]+') ); CREATE TABLE Address ( ID INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, Account VARCHAR(30) NOT NULL, Fname VARCHAR(15) NOT NULL, Lname VARCHAR(20) NOT NULL, Street VARCHAR(30) NOT NULL, City VARCHAR(25) NOT NULL, Province CHAR(2) NOT NULL, Postal_code VARCHAR(10) NOT NULL, Country VARCHAR(20) NOT NULL, Phone_num VARCHAR(12) NOT NULL, FOREIGN KEY (Account) REFERENCES Account (Email), CONSTRAINT provience_length CHECK (LENGTH(Province) = 2), CONSTRAINT phone_format CHECK (Phone_num ~ '[0-9]{3}-[0-9]{3}-[0-9]{4}') ); CREATE TABLE Card ( Card_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, Account VARCHAR(30), Card_num CHAR(16) NOT NULL, Name VARCHAR(40) NOT NULL, Expiry Date NOT NULL, CVV VARCHAR(4) NOT NULL, Address INT NOT NULL, FOREIGN KEY (Account) REFERENCES Account (Email), FOREIGN KEY (Address) REFERENCES Address (ID), CONSTRAINT card_num_length CHECK (LENGTH(Card_num) = 16), CONSTRAINT not_expired CHECK (Expiry > CURRENT_DATE), CONSTRAINT valid_cvv CHECK (CVV ~ '[0-9]{3,4}') ); CREATE TABLE Book_order ( Number INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, Account VARCHAR(30), Total numeric(6, 2) NOT NULL, Billing INT NOT NULL, Ship_address INT NOT NULL, Order_date DATE NOT NULL DEFAULT CURRENT_DATE, Tracking VARCHAR(50), Cur_location VARCHAR(25) DEFAULT 'Processing', Expected_date DATE, Arrival_date DATE, FOREIGN KEY (Account) REFERENCES Account (Email), FOREIGN KEY (Billing) REFERENCES Card (Card_id), FOREIGN KEY (Ship_address) REFERENCES Address (ID), CONSTRAINT positive_total CHECK (Total > 0), CONSTRAINT valid_dates CHECK ( Expected_date >= Order_date AND Arrival_date >= Order_date ) ); CREATE TABLE Sale ( Book CHAR(10), Order_num INT, Quantity SMALLINT NOT NULL, PRIMARY KEY (Book, Order_num), FOREIGN KEY (Book) REFERENCES Book (ISBN), FOREIGN KEY (Order_num) REFERENCES Book_order (Number) ON DELETE CASCADE, CONSTRAINT positiive_quantity CHECK (Quantity > 0) ); CREATE MATERIALIZED VIEW Storefront AS SELECT ISBN, Title, Cover, Publisher, Blurb, Price, page_num, Book_format, Release_date, Stock > 0 AS inStock FROM Book WHERE Selling = TRUE ORDER BY Copies_sold; CREATE OR REPLACE FUNCTION update_store() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$ BEGIN REFRESH MATERIALIZED VIEW Storefront; RETURN NEW; END; $$; CREATE OR REPLACE FUNCTION change_book_stock() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$ DECLARE curr_stock integer; BEGIN SELECT Stock INTO curr_stock FROM Book WHERE Book.ISBN = NEW.Book; IF ((curr_stock - NEW.Quantity) < 0) THEN RAISE EXCEPTION 'Not enough stock'; DELETE FROM Book_order WHERE Number = New.Order_num; ELSE UPDATE Book SET Stock = (Stock - NEW.Quantity), Copies_sold = Copies_sold + NEW.Quantity WHERE Book.ISBN = NEW.Book; END IF; RETURN NEW; END; $$; CREATE OR REPLACE FUNCTION fix_stock() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$ BEGIN UPDATE Book SET Stock = (Stock + OLD.Quantity), Copies_sold = Copies_sold + OLD.Quantity WHERE Book.ISBN = OLD.Book; RETURN OLD; END; $$; CREATE OR REPLACE FUNCTION order_stock() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$ DECLARE pubEmail CHAR(30); toOrder INTEGER; monthAgo DATE = (CURRENT_DATE - interval '1 month')::date; BEGIN SELECT Email INTO pubEmail FROM Book JOIN Publisher ON Book.Publisher = Publisher.Name WHERE Book.ISBN = NEW.ISBN; SELECT Units_sold INTO toOrder FROM get_sales_report(monthAgo, CURRENT_DATE) WHERE Purchased = NEW.ISBN; toOrder = COALESCE(toOrder, 0); IF((NEW.Stock + toOrder) < 10) THEN toOrder = (10 - NEW.Stock); END IF; RAISE NOTICE 'Ordered % of % via %', toOrder, NEW.ISBN, pubEmail; UPDATE Book SET Stock = (Stock + toOrder) WHERE ISBN = NEW.ISBN; RETURN NEW; END; $$; CREATE OR REPLACE FUNCTION set_order_total(order_number int) RETURNS numeric LANGUAGE PLPGSQL AS $$ DECLARE Order_total integer; BEGIN UPDATE Book_order SET Total = ( SELECT SUM(Book.Price * Sale.Quantity) FROM Sale JOIN Book ON Sale.Book = Book.ISBN JOIN Book_order ON Sale.Order_num = Book_order.Number WHERE Book_order.Number = order_number ) WHERE Book_order.Number = order_number RETURNING Total INTO Order_total; RETURN Order_total; END; $$; CREATE OR REPLACE FUNCTION check_order_accounts() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$ BEGIN IF NEW.Account NOT IN ( SELECT Address.Account FROM Address JOIN Card ON Address.Account = Card.Account WHERE Address.ID = NEW.Ship_address AND Card.Card_id = NEW.Billing ) THEN RAISE EXCEPTION 'Accounts for order, billing, and ship address do not match'; END IF; RETURN NEW; END; $$; CREATE OR REPLACE FUNCTION check_card_accounts() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$ BEGIN IF NEW.Account NOT IN ( SELECT Address.Account FROM Address WHERE Address.ID = NEW.Address ) THEN RAISE EXCEPTION 'Accounts for card and address do not match'; END IF; RETURN NEW; END; $$; CREATE OR REPLACE FUNCTION get_sales_report(from_date DATE, to_date DATE) RETURNS TABLE ( Purchased CHAR, Units_sold SMALLINT, Total_revenue numeric(4, 2), Total_profit numeric(4, 2), Total_lost numeric(4, 2) ) LANGUAGE PLPGSQL AS $$ BEGIN RETURN query SELECT Book.ISBN AS Purchased, Sale.Quantity AS Units_sold, (Book.Price * Sale.Quantity) AS Total_revenue, ((Book.Price - (Book.Price * Book.Sale_Percent)) * Sale.Quantity) AS Total_profit, ((Book.Price * Book.Sale_Percent) * Sale.Quantity) AS Total_lost FROM Sale JOIN Book ON Sale.Book = Book.ISBN JOIN Book_order ON Sale.Order_num = Book_order.Number WHERE Order_date >= from_date AND Order_date <= to_date; END; $$; CREATE OR REPLACE FUNCTION get_genre_report(from_date DATE, to_date DATE) RETURNS TABLE ( Genre VARCHAR, Total_sales BIGINT, Total_revenue numeric(4, 2), Total_profit numeric(4, 2), Profit_lost numeric(4, 2) ) LANGUAGE PLPGSQL AS $$ BEGIN RETURN query SELECT Genre.Name, SUM(r.Units_sold) AS Total_sales, SUM(r.Total_revenue) AS Total_revenue, SUM(r.Total_profit) AS Total_profit, SUM(r.Total_lost) AS Profit_lost FROM Book JOIN Genre ON Book.ISBN = Genre.Book JOIN get_sales_report(from_date, to_date) r ON Book.ISBN = r.Purchased GROUP BY Genre.Name; END; $$; CREATE OR REPLACE FUNCTION get_author_report(from_date DATE, to_date DATE) RETURNS TABLE ( Author VARCHAR, Total_sales BIGINT, Total_revenue numeric(4, 2), Total_profit numeric(4, 2), Profit_lost numeric(4, 2) ) LANGUAGE PLPGSQL AS $$ BEGIN RETURN query SELECT Authored.Author, SUM(r.Units_sold) AS Total_sales, SUM(r.Total_revenue) AS Total_revenue, SUM(r.Total_profit) AS Total_profit, SUM(r.Total_lost) AS Profit_lost FROM Book JOIN Authored ON Book.ISBN = Authored.Book JOIN get_sales_report(from_date, to_date) r ON Book.ISBN = r.Purchased GROUP BY Authored.Author; END; $$; CREATE TRIGGER update_store AFTER INSERT OR UPDATE ON Book FOR EACH STATEMENT EXECUTE PROCEDURE update_store(); CREATE OR REPLACE TRIGGER change_stock AFTER INSERT ON Sale FOR EACH ROW EXECUTE PROCEDURE change_book_stock(); CREATE TRIGGER fix_stock AFTER DELETE ON Sale FOR EACH ROW EXECUTE PROCEDURE fix_stock(); CREATE OR REPLACE TRIGGER order_stock AFTER UPDATE OF Stock ON Book FOR EACH ROW WHEN (NEW.Stock < 10) EXECUTE PROCEDURE order_stock(); CREATE TRIGGER order_insert BEFORE INSERT ON Book_order FOR EACH ROW EXECUTE PROCEDURE check_order_accounts(); CREATE TRIGGER order_insert BEFORE INSERT ON Card FOR EACH ROW EXECUTE PROCEDURE check_card_accounts();"
}